# Custom Commit Message Format Feature

## Overview
Add support for customizable commit message format using a template string pattern with dynamic variable prompting.

## Format Specification
- Format template example: `{type} ({context}) {msg} (#{gitBranchNumber})`
- System Variables (automatically handled):
  - `{type}`: Commit type (feat, fix, docs, etc.) - Generated by LLM based on diff.
  - `{gitBranch}`: Current full git branch name (e.g., `feature/TKT-123-login`).
  - `{gitBranchNumber}`: The first sequence of digits found in the current git branch name (e.g., `123`). Empty if no digits found.
  - `{msg}`: The core commit message generated by the LLM based on the diff. This is implicitly handled and placed where `{msg}` appears in the format.
- Custom Variables:
  - Any variable in format `{variableName}` that is not a system variable will prompt the user for a description on first use.
  - Example: `{context}` will prompt user to describe what context means.

## Configuration

### Storage
- File: `.commiat` in working directory (cwd)
- Format: JSON
- Content Structure:
  ```json
  {
    "format": "{type} ({context}) {msg} (#{gitBranchNumber})",
    "variables": {
      "context": "affected app module such as location-module, events-module, alerts-module, etc"
    }
  }
  ```

### Variable Handling
1. System variables (`type`, `gitBranch`, `gitBranchNumber`, `msg`): Handled automatically. `type` and `msg` rely on LLM generation guided by the prompt; `gitBranch` and `gitBranchNumber` are fetched from Git.
2. Custom variables: CLI prompts for description on first use if description is missing in `.commiat`.
3. All variable descriptions (for custom variables) are stored in config and sent to LLM.
4. System variable *values* (`gitBranch`, `gitBranchNumber`) are also sent to the LLM for context if they appear in the format string.

## Implementation Plan

### 1. Configuration Management
- Create module `src/config.js`
  - Function: `loadConfig()`: Read .commiat config, prompt to create if missing.
  - Function: `saveConfig(config)`: Save/update config.
  - Function: `validateConfig(config)`: Validate structure.

### 2. Variable Processing
- Create module `src/variables.js`
  - Function: `detectVariables(format)`: Extract all variables from format.
  - Function: `promptForMissingVariableDescriptions(variables, config)`: Interactive CLI prompts for custom var descriptions.
  - Function: `getSystemVariableValues()`: Get values for `gitBranch`, `gitBranchNumber`.

### 3. Git Integration
- Create module `src/utils/git.js`
  - Function: `getGitBranch()`: Get current branch name.
  - Function: `getGitBranchNumber()`: Extract first number sequence from branch name.
  - Add debug logs and error handling.

### 4. LLM Integration
- Update system prompt generation in `src/cli.js`:
  - Include the `format` template.
  - Include all custom variable descriptions from `config.variables`.
  - Include the resolved values for system variables (`gitBranch`, `gitBranchNumber`) if they are present in the format string.
  - Clear instructions about variable placement and adhering to the format.
- Validate LLM output (basic cleanup, e.g., remove markdown fences).

### 5. Error Handling
- Validate config file structure.
- Handle missing git branch / number extraction gracefully (return empty string).
- Add debug logs for all operations.
- Improve API error reporting.

## Example Usage

### First Run (No Config)
```bash
$ commiat
# CLI detects no .commiat file
? Enter commit message format: {type}({module}): {msg} - Ticket {gitBranchNumber}
? Describe what you expect for {module}: The specific code module being changed
# Config saved to .commiat
```

### Subsequent Runs (Branch: feat/AUTH-456-login)
```bash
$ commiat
# Uses existing format and variable descriptions
# Fetches gitBranch="feat/AUTH-456-login", gitBranchNumber="456"
# Prompts only for commit confirmation/adjustment
# LLM generates message like: feat(Auth): add password reset endpoint - Ticket 456
```

### Example Output
```
feat(Auth): add password reset endpoint - Ticket 456
```

## Testing Plan
1. Test format processing with different templates including `{gitBranchNumber}`.
2. Test git branch detection and number extraction in various states (e.g., `feature/123`, `bugfix/no-number`, `release/v1.2.3`, detached HEAD).
3. Test error handling for invalid formats or missing descriptions.
4. Test LLM output compliance with format, including correct placement of system variable values.
5. Test initial config creation flow.
